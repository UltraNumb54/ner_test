import json
import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification
import numpy as np

class ServiceClassifier:
    def __init__(self, model_path):
        """
        Инициализация классификатора для предсказания service
        """
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        
        # Загрузка информации о метках
        with open(f"{model_path}/label_info.json", 'r', encoding='utf-8') as f:
            label_info = json.load(f)
            self.id2label = label_info['id2label']
            self.label2id = label_info['label2id']
        
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        print(f"Используется устройство: {self.device}")
        self.model.to(self.device)
        self.model.eval()
    
    def predict(self, text, return_probabilities=False, top_k=3):
        """
        Предсказание service для текста
        """
        # Токенизация
        inputs = self.tokenizer(
            text,
            padding=True,
            truncation=True,
            max_length=512,
            return_tensors="pt"
        )
        
        # Перенос на устройство
        inputs = {k: v.to(self.device) for k, v in inputs.items()}
        
        # Предсказание
        with torch.no_grad():
            outputs = self.model(**inputs)
        
        # Получение вероятностей
        probabilities = torch.nn.functional.softmax(outputs.logits, dim=-1)
        predicted_class_id = probabilities.argmax().item()
        predicted_service = self.id2label[str(predicted_class_id)]
        
        if return_probabilities:
            # Возвращаем топ-K вероятностей
            all_probs = probabilities.cpu().numpy()[0]
            top_k_indices = np.argsort(all_probs)[-top_k:][::-1]
            top_k_probs = {
                self.id2label[str(i)]: float(all_probs[i]) 
                for i in top_k_indices
            }
            return predicted_service, top_k_probs
        else:
            return predicted_service
    
    def predict_batch(self, texts, return_probabilities=False, top_k=3):
        """
        Пакетное предсказание для списка текстов
        """
        results = []
        
        for text in texts:
            if return_probabilities:
                prediction, probabilities = self.predict(text, return_probabilities=True, top_k=top_k)
                results.append({
                    'text': text,
                    'predicted_service': prediction,
                    'probabilities': probabilities
                })
            else:
                prediction = self.predict(text)
                results.append({
                    'text': text,
                    'predicted_service': prediction
                })
        
        return results

# Пример использования
def test_classifier():
    """
    Тестирование обученного классификатора
    """
    MODEL_PATH = "./service_classifier"  # Путь к обученной модели
    
    try:
        classifier = ServiceClassifier(MODEL_PATH)
        
        # Тестовые примеры
        test_texts = [
            "Помогите настроить подключение к интернету",
            "Не работает принтер в офисе",
            "Нужно обновить программное обеспечение",
            "Проблема с электронной почтой",
            "Сломался компьютер, не включается"
        ]
        
        print("Тестирование классификатора:")
        print("=" * 60)
        
        results = classifier.predict_batch(test_texts, return_probabilities=True, top_k=3)
        
        for i, result in enumerate(results, 1):
            print(f"{i}. Текст: {result['text']}")
            print(f"   Предсказанный service: {result['predicted_service']}")
            print("   Топ-3 вероятности:")
            for service, prob in result['probabilities'].items():
                print(f"     {service}: {prob:.4f}")
            print("-" * 40)
            
    except Exception as e:
        print(f"Ошибка при тестировании классификатора: {e}")

if __name__ == "__main__":
    test_classifier()
