import xmltodict
import json
import re
import html
from typing import List, Dict, Any
import os

class XMLToNERConverter:
    def __init__(self, max_chunk_length: int = 1000):
        self.max_chunk_length = max_chunk_length
        
    def clean_text(self, text: str) -> str:
        """
        Очистка текста от проблемных символов и нормализация
        """
        if not text:
            return ""
            
        # Декодируем HTML entities
        text = html.unescape(text)
        
        # Заменяем проблемные кавычки
        text = text.replace('"', "'")
        
        # Удаляем управляющие символы и непечатаемые символы
        text = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', '', text)
        
        # Заменяем множественные пробелы и переносы
        text = re.sub(r'\s+', ' ', text)
        
        # Удаляем начальные и конечные пробелы
        text = text.strip()
        
        return text
    
    def split_text_into_chunks(self, text: str) -> List[str]:
        """
        Разбивка длинного текста на логические части
        """
        if len(text) <= self.max_chunk_length:
            return [text]
        
        chunks = []
        current_chunk = ""
        sentences = re.split(r'(?<=[.!?])\s+', text)
        
        for sentence in sentences:
            if len(current_chunk) + len(sentence) > self.max_chunk_length and current_chunk:
                chunks.append(current_chunk.strip())
                current_chunk = sentence
            else:
                if current_chunk:
                    current_chunk += " " + sentence
                else:
                    current_chunk = sentence
        
        if current_chunk.strip():
            chunks.append(current_chunk.strip())
            
        return chunks
    
    def tokenize_text(self, text: str) -> List[str]:
        """
        Токенизация текста для русского языка
        """
        if not text:
            return []
        
        # Улучшенная токенизация для русского языка
        token_regex = r'[\w\u0400-\u04FF@]+|[^\w\s]|_+'
        tokens = re.findall(token_regex, text)
        
        return [token for token in tokens if token.strip()]
    
    def extract_text_from_description(self, description_element) -> str:
        """
        Извлечение текста из description с учетом CDATA
        """
        if description_element is None:
            return ""
            
        # xmltodict сохраняет CDATA как обычный текст
        if isinstance(description_element, dict):
            # Если description содержит сложную структуру
            return self.extract_text_from_dict(description_element)
        elif isinstance(description_element, str):
            return self.clean_text(description_element)
        else:
            return self.clean_text(str(description_element))
    
    def extract_text_from_dict(self, data_dict: Dict) -> str:
        """
        Рекурсивно извлекает текст из сложных словарных структур
        """
        if isinstance(data_dict, str):
            return data_dict
        
        text_parts = []
        
        # Рекурсивно обходим словарь
        for key, value in data_dict.items():
            if isinstance(value, dict):
                text_parts.append(self.extract_text_from_dict(value))
            elif isinstance(value, list):
                for item in value:
                    text_parts.append(self.extract_text_from_dict(item))
            elif value is not None:
                text_parts.append(str(value))
        
        return ' '.join(text_parts)
    
    def convert_xml_to_json(self, xml_file_path: str, output_file: str = None) -> List[Dict[str, Any]]:
        """
        Основной метод конвертации XML в JSON
        """
        try:
            # Читаем XML файл
            with open(xml_file_path, 'r', encoding='utf-8') as file:
                xml_content = file.read()
            
            # Парсим XML в словарь с помощью xmltodict
            data_dict = xmltodict.parse(xml_content)
            
        except Exception as e:
            raise ValueError(f"Ошибка парсинга XML: {e}")
        
        dataset = []
        record_count = 0
        chunk_count = 0
        
        # Обрабатываем структуру данных
        records = data_dict.get('data', {}).get('record', [])
        if not isinstance(records, list):
            records = [records]
        
        for record in records:
            record_count += 1
            
            # Извлекаем базовые поля
            record_id = record.get('id', '')
            service = record.get('service', '')
            topic = record.get('topic', '')
            
            # Обрабатываем description
            description_content = record.get('description', '')
            original_text = self.extract_text_from_description(description_content)
            
            if not original_text:
                print(f"Предупреждение: запись {record_id} не содержит текста")
                continue
            
            # Разбиваем текст на части если нужно
            text_chunks = self.split_text_into_chunks(original_text)
            
            # Обрабатываем attachments
            attachments = record.get('attachments', [])
            if not isinstance(attachments, list):
                attachments = [attachments] if attachments else []
            
            for chunk_index, chunk_text in enumerate(text_chunks):
                chunk_count += 1
                
                # Токенизируем текст
                tokens = self.tokenize_text(chunk_text)
                
                # Создаем запись для датасета
                dataset_entry = {
                    "id": f"{record_id}_{chunk_index}",
                    "original_text": chunk_text,
                    "tokens": tokens,
                    "ner_tags": ["O"] * len(tokens),
                    "success": False,
                    "metadata": {
                        "original_id": str(record_id),
                        "service": self.clean_text(str(service)),
                        "topic": self.clean_text(str(topic)),
                        "attachments_count": len(attachments),
                        "chunk_index": chunk_index,
                        "total_chunks": len(text_chunks)
                    }
                }
                
                dataset.append(dataset_entry)
        
        print(f"Обработано записей: {record_count}")
        print(f"Создано чанков: {chunk_count}")
        print(f"Всего элементов в датасете: {len(dataset)}")
        
        # Сохраняем в файл если указан output
        if output_file:
            self.save_to_json(dataset, output_file)
            print(f"Датасет сохранен в: {output_file}")
        
        return dataset
    
    def save_to_json(self, dataset: List[Dict], output_file: str):
        """
        Сохранение датасета в JSON файл
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(dataset, f, ensure_ascii=False, indent=2)
    
    def save_to_jsonl(self, dataset: List[Dict], output_file: str):
        """
        Сохранение датасета в JSONL формат (одна строка - один JSON)
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            for item in dataset:
                json.dump(item, f, ensure_ascii=False)
                f.write('\n')

# ПРЯМОЕ УКАЗАНИЕ ПУТЕЙ В КОДЕ
if __name__ == "__main__":
    # УКАЖИТЕ ПУТИ К ФАЙЛАМ ЗДЕСЬ
    INPUT_XML_FILE = "data.xml"  # Путь к вашему XML файлу
    OUTPUT_JSON_FILE = "ner_dataset.json"  # Путь для сохранения JSON
    
    # Параметры конвертации
    MAX_CHUNK_LENGTH = 1000  # Максимальная длина текстового чанка
    USE_JSONL_FORMAT = False  # Использовать JSONL формат вместо JSON
    
    # Проверяем существование входного файла
    if not os.path.exists(INPUT_XML_FILE):
        print(f"Ошибка: файл {INPUT_XML_FILE} не найден!")
        print("Убедитесь, что файл существует в указанной директории.")
        exit(1)
    
    # Создаем конвертер и выполняем конвертацию
    converter = XMLToNERConverter(max_chunk_length=MAX_CHUNK_LENGTH)
    
    try:
        dataset = converter.convert_xml_to_json(INPUT_XML_FILE, None)
        
        if USE_JSONL_FORMAT:
            output_file = OUTPUT_JSON_FILE.replace('.json', '.jsonl') if OUTPUT_JSON_FILE.endswith('.json') else OUTPUT_JSON_FILE + '.jsonl'
            converter.save_to_jsonl(dataset, output_file)
        else:
            converter.save_to_json(dataset, OUTPUT_JSON_FILE)
            
        print("Конвертация завершена успешно!")
        
    except Exception as e:
        print(f"Ошибка при конвертации: {e}")
